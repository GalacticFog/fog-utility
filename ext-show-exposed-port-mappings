#!/usr/bin/env node
'use strict';
const argv = require('yargs').argv
const displayResource = require('./lib/displayResourceUI');
const chalk = require('chalk')
const fs = require('fs');
const AWS = require('aws-sdk');

// Check for arguments
if (argv._.length == 0) {
    console.error(`Usage: `)
    return
}

const config = getJsonFromFile(argv._[0]);

const elb = new AWS.ELB(config['aws-elb']);

var params = {
    LoadBalancerNames: config.elbs
};

const kuberesponse = getJsonFromFile('./kuberesponse-prod.json');

console.log("Reading ELB info...");
elb.describeLoadBalancers(params, function (err, lbs) {
    if (err) {
        console.log(err, err.stack); // an error occurred
    } else {

        // Merge in Kubernetes service information
        console.log("Reading Cluster service info...");
        displayKubeServices(kuberesponse, function (err, data) {
            if (err) {
                console.log(err, err.stack); // an error occurred
            } else {

                // Iterate through LBs
                lbs.LoadBalancerDescriptions.map(lbd => {

                    const listeners = lbd.ListenerDescriptions.map(item => {
                        return item.Listener;
                    });

                    // Attach kube
                    listeners.map(item => {
                        item.port = data[item.InstancePort];
                        data[item.InstancePort].accountedFor = true; // Mark accounted for to filter out later
                    });

                    // Display
                    displayOutput(lbd.LoadBalancerName, listeners);
                });

                displayNonMappedPorts(data);
        
            }
        });
    };
});


function displayOutput(name, listeners) {
    const options = {
        headers: ['LB Port', 'LB Protocol', 'Cluster Port', 'Cluster Protocol', 'Service Name', 'Port', 'Protocol', 'Name', 'Namespace'],
        fields: ['LoadBalancerPort', 'Protocol', 'InstancePort', 'InstanceProtocol', 'port.serviceName', 'port.port', 'port.protocol', 'port.name', 'port.namespace'],
        sortField: 'LoadBalancerPort',
        emptyString: '-'
    }

    const resources = listeners.filter(item => {
        return item.port.namespace != 'gestalt-system' && item.port.namespace != 'kube-system';
    });

    // Output
    console.log();
    console.log(chalk.green.bold(`${name} ELB`));
    displayResource.run(options, resources);
}

function displayNonMappedPorts(data) {
    const options = {
        headers: ['LB Port', 'LB Protocol', 'Cluster Port', 'Cluster Protocol', 'Service Name', 'Port', 'Protocol', 'Name', 'Namespace'],
        fields: ['a', 'b', 'nodePort', 'c', 'serviceName', 'port', 'protocol', 'name', 'namespace'],
        sortField: 'nodePort',
        emptyString: '-'
    }

    let resources = Object.values(data);

    // Exclude services that were accounted for on other ELBs
    resources = resources.filter(item => {
        return !item.accountedFor;
    });

    // Hide gestalt-* and kube-* namespaces
    resources = resources.filter(item => {
        return item.namespace.indexOf('gestalt-') != 0 && item.namespace.indexOf('kube-') != 0;
    });

    // Hide Gestalt related services
    resources = resources.filter(item => {
        return item.serviceName.indexOf("gestalt-") != 0 &&
            item.serviceName.indexOf('default-') != 0;
    });

    // Output
    console.log();
    console.log(chalk.blue.bold(`Exposed Services not mapped on the above ELBs`));
    displayResource.run(options, resources);
}

function displayKubeServices(kuberesponse, callback) {

    // Transform and flatten
    let resources = kuberesponse.items.map(item => {
        const res2 = item.spec.ports.map(port => {
            port.serviceName = item.metadata.name;
            port.namespace = item.metadata.namespace;
            return port;
        });
        return res2;
    });

    resources = [].concat.apply([], resources); // flatten array


    // Index by nodeport
    const resourcesByNodePort = {};

    resources.map(res => {
        resourcesByNodePort[res.nodePort] = res;
    });

    callback(null, resourcesByNodePort);
}


function getJsonFromFile(file) {
    const f = file;
    if (fs.existsSync(f)) {
        const contents = fs.readFileSync(f, 'utf8');
        return JSON.parse(contents);
    }
    return {};
}
