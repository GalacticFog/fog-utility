#!/usr/bin/env node
const argv = require('yargs').argv
const gestalt = require('./lib/gestalt');
const gestaltState = require('./lib/gestalt-state');
const displayResource = require('./lib/displayResourceUI');
const request = require('sync-request');
const chalk = require('chalk');
const inquirer = require('inquirer');
const SERVICES_CONFIG_FILE = 'external-port-mapping-config.json';
const CACHED_CONFIG_FILE = 'external-port-mapping-servie.json.cached';
const selectResource = require('./lib/selectResourceUI');
const displayAmazon = require('./lib/displayAmazon');
const selectElbListeners = require('./lib/selectElbListeners');

if (argv._.length < 1) {
    printUsage();
    process.exit(1);
}

const COMMAND = argv._[0];

switch (COMMAND) {
    case 'configure':
        configure();
        return;
    case 'list-clusters':
        listClusters();
        return;
}

// Other commands require the cluster
if (!argv.cluster) {
    console.log('missing --cluster <cluster>');
    printUsage();
    process.exit(1);
}

const CLUSTER = argv.cluster;

main();

function printUsage() {
    console.log(`Usage:`);
    console.log();
    console.log(`  list port mappings:     ${argv['$0']} --cluster <cluster> list`);
    console.log(`  create port mapping:    ${argv['$0']} --cluster <cluster> create --name <port mapping>`);
    console.log(`  delete port mapping:    ${argv['$0']} --cluster <cluster> delete --name <port mapping>`);
    console.log(`  configure:        ${argv['$0']} configure`);
    console.log();
}

function main() {

    let configureNeeded = !gestaltState.fileExists(SERVICES_CONFIG_FILE);

    if (configureNeeded) {
        console.log(`'${SERVICES_CONFIG_FILE}' not found, please run '${argv['$0']} configure'`);
        process.exit(1);
    }

    switch (COMMAND) {
        case 'configure':
            configure();
            break;
        case 'list':
            listMappings();
            break;
        case 'create':
            createExternalPortMappingInteractive();
            break;
        case 'delete':
            // deleteMapping();
            deleteExternalPortMappingInteractive();
            break;
        default:
            console.log('Nothing');
    }
}

function configure(callback) {

    // Prompt to continue
    const questions = [
        {
            message: "Enter the service URL:",
            type: 'input',
            name: 'service_config_url',
        },
    ];

    let config = {};
    if (gestaltState.fileExists(SERVICES_CONFIG_FILE)) {
        config = gestaltState.loadConfigFile(SERVICES_CONFIG_FILE);
        if (config.service_config_url) {
            questions[0].default = config.service_config_url;
        }
    }

    inquirer.prompt(questions).then(answers => {
        const contents = JSON.stringify(answers, null, '  ');
        gestaltState.writeFile(SERVICES_CONFIG_FILE, contents);
        console.log(`Configuration saved to ${SERVICES_CONFIG_FILE}.`);

        if (callback) callback();
    });
}


function createMapping(elb, lbProto, lbPort, instProto, instPort) {
    const cluster = argv.cluster;
    const listener = {
        InstancePort: instPort,
        InstanceProtocol: instProto,
        LoadBalancerPort: lbPort,
        Protocol: lbProto
    };

    const resources = doPut(`/clusters/${cluster}/elbs/${elb}/ports/${lbPort}`, listener);
}

function deleteMapping(elb, lbPort) {
    const cluster = argv.cluster;
    if (!lbPort) throw Error(`missing lbPort`);

    doDelete(`/clusters/${cluster}/elbs/${elb}/ports/${lbPort}`);
}


function deleteMapping2() {
    try {
        const name = argv.name;
        const cluster = argv.cluster;

        if (!name) throw Error('missing name');
        if (!cluster) throw Error('missing cluster');

        console.log(`Fetching volume information from cluster '${cluster}'...`);
        const volume = doGet(`/volumes/${name}`);
        if (!argv.force && volume.status.phase == 'Bound') {
            console.log(`Not deleting volume '${name}' because status is '${volume.status.phase}', use '--force' to override.`);
        } else {
            console.log();
            promptToContinue(`Proceed to delete volume '${name}' on cluster '${cluster}'?`, confirmed => {
                if (confirmed) {
                    console.log(`Deleting volume '${name}' on cluster '${cluster}'...`);
                    gestalt.httpDelete(`${url}/volumes/${name}`);
                    console.log('Done.');
                } else {
                    console.log(`Aborted.`);
                }
            });
        }
    } catch (err) {
        console.log(err.message);
        console.log();
    }
}

function listClusters() {
    try {
        console.log(`Fetching clusters information...`);
        let resources = doGet(`/clusters`);
        resources = resources.map(r => {
            return chalk.green(`'${r}'`);
        });

        console.log();
        console.log(chalk.bold('Clusters: ') + resources.join(', '));
        console.log();
    } catch (err) {
        console.log(err.message);
        console.log();
    }
}

function doGet(path) {
    const url = getServiceUrl();
    let resources = gestalt.httpGet(`${url}${path}`);
    return resources;
}

function doDelete(path) {
    const url = getServiceUrl();
    gestalt.httpDelete(`${url}${path}`);
}

function doPut(path, body) {
    const url = getServiceUrl();
    let resources = gestalt.httpPut(`${url}${path}`, body);
    return resources;
}

function listMappings() {
    try {
        const cluster = argv.cluster;

        console.log(`Fetching volumes information from cluster '${cluster}'...`);
        let resources = doGet(`/clusters/${cluster}/external_mappings`);

        // console.log(JSON.stringify(resources, null, 2))

        if (!argv.all) {
            console.log(`Filtering out system services, use '--all' to override`);
        }

        resources.elbs.map(elb => {
            displayOutput(elb.name, elb.listeners);
        })

        displayNonMappedPorts(resources.unmapped_services);

        console.log(`Note: Non-mapped services are not exposed on the above ELBs, but may be exposed elsewhere.`);
        console.log();

    } catch (err) {
        console.log(err.message);
        console.log();
    }
}


function displayOutput(name, listeners) {
    const options = {
        headers: ['LB Port', 'LB Protocol', 'Cluster Port', 'Cluster Protocol', 'Service Name', 'Port', 'Protocol', 'Name', 'Namespace'],
        fields: ['LoadBalancerPort', 'Protocol', 'InstancePort', 'InstanceProtocol', 'mapped_service.serviceName', 'mapped_service.port', 'mapped_service.protocol', 'mapped_service.name', 'mapped_service.namespace'],
        sortField: 'LoadBalancerPort',
        emptyString: '-'
    }

    let resources = listeners.map(i => i);

    if (!argv.all) {
        resources = resources.filter(item => {
            return item.mapped_service.namespace != 'gestalt-system' && item.mapped_service.namespace != 'kube-system';
        });
    }

    // Output
    console.log();
    console.log(chalk.green.bold(`ELB: ${name}`));
    displayResource.run(options, resources);
}

function displayNonMappedPorts(data) {
    const options = {
        headers: ['LB Port', 'LB Protocol', 'Cluster Port', 'Cluster Protocol', 'Service Name', 'Port', 'Protocol', 'Name', 'Namespace'],
        fields: ['a', 'b', 'nodePort', 'c', 'serviceName', 'port', 'protocol', 'name', 'namespace'],
        sortField: 'serviceName',
        emptyString: '-'
    }

    let resources = Object.values(data);

    // Exclude services that were accounted for on other ELBs
    resources = resources.filter(item => {
        return !item.accountedFor;
    });

    // Hide gestalt-* and kube-* namespaces
    resources = resources.filter(item => {
        // return item.namespace.indexOf('gestalt-') != 0 && item.namespace.indexOf('kube-') != 0;
        return item.namespace.indexOf('kube-') != 0;
    });

    // // Hide Gestalt related services
    // resources = resources.filter(item => {
    //     return item.serviceName.indexOf("gestalt-") != 0 &&
    //         item.serviceName.indexOf('default-') != 0;
    // });

    // Output
    console.log();
    console.log(chalk.blue.bold(`Exposed Services not mapped on the above ELBs`));
    displayResource.run(options, resources);
}



function loadClusterConfig(key) {
    const f = gestaltState.getConfigDir() + `/cluster-${key}.json`;
    if (fs.existsSync(f)) {
        const contents = fs.readFileSync(f, 'utf8');
        return JSON.parse(contents);
    }
    throw new Error(`${f} not found`);
}


function getServiceUrl() {
    return getOrFetchServiceConfig()['service_url'];
}

function getOrFetchServiceConfig() {
    const file = CACHED_CONFIG_FILE;
    if (gestaltState.fileExists(file)) {
        return gestaltState.loadConfigFile(file);
    }

    // Don't have it, attmept to download
    console.log(`${file} not found, fetching...`);

    const volumesConfig = gestaltState.loadConfigFile(SERVICES_CONFIG_FILE);
    console.log(JSON.stringify(volumesConfig))
    const url = volumesConfig['service_config_url'];
    const res = request('GET', `${url}`);

    const body = res.getBody();
    if (body.length > 0) {
        gestaltState.writeFile(file, JSON.stringify(JSON.parse(body), null, 2));

        // Now write to file
        return gestaltState.loadConfigFile(file);
    }
    throw Error(`Could not load config for cluster ${cluster}`);
}

function promptToContinue(message, callback) {
    // Prompt to continue
    const questions = [
        {
            message: message,
            type: 'confirm',
            name: 'confirm',
            default: false
        },
    ];
    inquirer.prompt(questions).then(answers => {
        const contents = JSON.stringify(answers, null, '  ');

        if (answers.confirm) {
            callback(true);
        } else {
            callback(false);
        }
    });
}


function deleteExternalPortMappingInteractive() {
    // Select ELB to expose to
    const lbs = doGet(`/clusters/${argv.cluster}/elbs`);

    selectELB(lbs, (err, elb) => {
        if (err) {
            console.error(chalk.red(`Error: ${err.message}`));
            return;
        }

        // Collect user input
        selectElbListeners.run({}, elb, (selectedListeners) => {

            console.log(selectedListeners);

            // Display summary to the user before executing
            summarizeAndConfirmDeleteELBListener(elb, selectedListeners, () => {

                // Confirmed, perform the execution
                selectedListeners.map(listener => {
                    deleteMapping(elb.LoadBalancerName, listener.LoadBalancerPort);
                })

                const lbs = doGet(`/clusters/${argv.cluster}/elbs`);
                console.log(JSON.stringify(lbs, null, 2));
                lbs.map(lb => {
                    if (elb.LoadBalancerName == lb.LoadBalancerName) {
                        displayAmazon.displayDetails(lb);
                    }
                });
            });
        });
    });
}

function createExternalPortMappingInteractive() {

    const elbs = doGet(`/clusters/${argv.cluster}/elbs`);

    selectELB(elbs, (err, elb) => {
        if (err) {
            console.error(chalk.red(`Error: ${err.message}`));
            return;
        }

        // Show ELB Details
        displayAmazon.displayDetails(elb);

        // Collect user input
        userInput('ELB port to expose:', externalPort => {

            selectOptions('ELB Protocol', ['TCP', /*'HTTPS'*/, 'HTTP'], externalProtocol => {

                userInput("Instance Port to Expose:", internalPort => {

                    let protocols = null;
                    if (externalProtocol === 'TCP') {
                        protocols = ['TCP'];
                    } else {
                        protocols = ['HTTP'/*, 'HTTPS'*/];
                    }

                    selectOptions('ELB Protocol', protocols, internalProtocol => {
                        
                        const params = {
                            elb: elb,
                            listener: {
                                InstancePort: internalPort,
                                InstanceProtocol: internalProtocol,
                                LoadBalancerPort: externalPort,
                                Protocol: externalProtocol
                            }
                        };

                        // Display summary to the user before executing
                        summarizeAndConfirmCreateELBListener(params, () => {

                            // Confirmed, perform the execution
                            const l = params.listener;
                            createMapping(elb.LoadBalancerName, l.Protocol, l.LoadBalancerPort, l.InstanceProtocol, l.InstancePort);
                            console.log(chalk.bold.green("Added listener."));
                        });
                    });
                });
            });
        });
    });
}

// ----------------------------INTERACTIVE FUNCTIONS

function selectELB(lbs, callback) {

    const options = {
        mode: 'autocomplete',
        message: "Select ELB",
        fields: ['name', 'dnsname', 'listeners', 'zones', 'instances'],
        sortBy: 'name',
        fetchFunction: () => {
            return lbs.map(lbd => {
                return {
                    name: lbd.LoadBalancerName,
                    dnsname: lbd.DNSName,
                    listeners: `${lbd.ListenerDescriptions.length} listeners`,
                    zones: `${lbd.AvailabilityZones.join(',')}`,
                    instances: `${lbd.Instances.length} instances`,
                    value: Object.assign({}, lbd)
                }
            });
        }
    }

    selectResource.run(options, result => {
        console.log();
        console.log(`${result.value.LoadBalancerName} selected.`);
        console.log();

        callback(null, result.value);
    });
}

function userInput(message, callback) {
    const questions = [
        {
            message: message,
            type: 'input',
            name: 'value',
        },
    ];

    inquirer.prompt(questions).then(answers => {
        callback(answers.value);
    });
}

function selectOptions(message, opts, callback) {
    let options = {
        mode: 'list',
        message: message,
        fields: ['name'],
        sortBy: 'name',
        fetchFunction: () => {
            // Extract the listeners
            return opts.map(o => { return { name: o } });
        }
    }

    selectResource.run(options, selection => {
        if (callback) callback(selection.name);
    });
}


function summarizeAndConfirmCreateELBListener(params, callback) {

    // console.log(JSON.stringify(params, null, 2));

    console.log();
    console.log(chalk.bold(`The following listener will be added to ELB ${chalk.green(params.elb.LoadBalancerName)}:`));

    displayAction(params);

    // Prompt to continue
    const questions = [
        {
            message: "Proceed to add ELB listener?",
            type: 'confirm',
            name: 'confirm',
            default: false
        },
    ];

    inquirer.prompt(questions).then(answers => {
        const contents = JSON.stringify(answers, null, '  ');

        if (answers.confirm) {
            callback();
        } else {
            console.log("Aborted.")
        }
    });
}

function displayAction(params) {
    const resources = [{
        listener: params.listener,
        LoadBalancerName: params.elb.LoadBalancerName
    }];
    const options = {
        headers: ['LB Name', 'LB Port', 'LB Protocol', 'Cluster Port', 'Cluster Protocol'],
        fields: ['LoadBalancerName', 'listener.LoadBalancerPort', 'listener.Protocol', 'listener.InstancePort', 'listener.InstanceProtocol'],
        // sortField: 'LoadBalancerPort',
        emptyString: '-'
    }
    displayResource.run(options, resources);
}

function summarizeAndConfirmDeleteELBListener(elb, listeners, callback) {
    console.log();
    console.log(chalk.bold(`The following listeners will be deleted from ELB ${chalk.green(elb.LoadBalancerName)}:`));

    displayListeners(listeners);

    // Prompt to continue
    const questions = [
        {
            message: `Proceed to remove ${listeners.length} listeners from ${chalk.green(elb.LoadBalancerName)} ELB?`,
            type: 'confirm',
            name: 'confirm',
            default: false
        },
    ];

    inquirer.prompt(questions).then(answers => {
        const contents = JSON.stringify(answers, null, '  ');

        if (answers.confirm) {
            callback();
        } else {
            console.log("Aborted.")
        }
    });
}

function displayListeners(listeners) {
    const options = {
        headers: ['LB Port', 'LB Protocol', 'Cluster Port', 'Cluster Protocol'],
        fields: ['LoadBalancerPort', 'Protocol', 'InstancePort', 'InstanceProtocol'],
        sortField: 'LoadBalancerPort',
        emptyString: '-'
    }
    displayResource.run(options, listeners);
}
